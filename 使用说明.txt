本工具可将符合一定格式规范要求的Excel表格数据导出为lua能直接使用的lua table数据（需安装微软的AccessDatabaseEngine以提供读取Excel文件的支持）

Excel表格必须符合以下规范：
① 需要导出的Sheet表名称必须为data，每个表格中必须且仅存在一个，其余Sheet表不会被本工具识别，可以用于备份之前版本的表格、存储表格修改记录等
② 表格的前四行用于声明该列对应字段的描述、字段名、数据类型、检查规则，如下所示：
   道具名称  -> 字段描述，仅用于方便填表者备注，可不填，不会生成到最终的lua table中
   propName  -> 字段名，会被作为table中的key生成，如果某列不填写该字段名，则视为填表格添加的辅助列，该列数据不会被生成
   string    -> 字段数据类型，规定了这列数据的类型，详见下面对支持的数据类型的介绍。若该列字段名有效，则必须一并填写字段的数据类型
   unique    -> 字段检查规则，用于规定对这列数据的检查规则，详见下面对支持的检查规则的介绍，如果该列不需要进行检查则留空

其中表格的第一列为主键列，只能为int或string型，如果为string型主键，只能由英文字母、数字、下划线组成且不能为空或纯空格

本程序的配置文件config.txt需放在本程序所在目录下，里面用于配置经常变动的自定义表格检查规则。本程序启动时可传入lang文件路径，lang文件用于配置国际化文字对应各种语言的翻译
注意本工具所读取的所有txt格式的配置文件，必须采用UTF-8编码

本工具运行时需要顺序传入以下几个必填参数（参数与参数间用空格分隔）：
① Excel表格所在目录
② 存放导出lua文件的目录
③ 项目Client目录的路径（无需文件存在型检查规则则填-noClient）
④ lang文件路径（没有填-noLang）
后面还可以附加几个功能参数（输入顺序随意）：
① -columnInfo（在生成lua文件的最上方用注释形式显示列信息，默认不开启）
② -unchecked（不对表格进行查错，不推荐使用）
③ -printEmptyStringWhenLangNotMatching（当lang型数据key在lang文件中找不到对应值时，在lua文件输出字段值为空字符串即xx = ""，默认为输出nil）

---------------------------------------------------------------------------------------------------------
支持的数据类型如下：
① string 注意此类型的单元格中如果含有空格会被保留
② int 注意此类型不允许空值
③ float 注意此类型不允许空值
④ lang 填写在lang文件中的key，生成工具自动找到对应的value进行替换
⑤ bool 填写数字1表示true，0表示false，其他值非法，不允许空值
⑥ dict 格式为dict[子元素个数]，用于表示组成一个复杂数据结构的相关元素的集合，比如用一个dict可以表示一个reward，dict[3] 其后三列为 type(int)、id(int)、count(int)。注意dict下的子元素不允许出现变量名相同
⑦ array 格式为array[类型:个数]，用于表示多个相同数据结构组成的列表，比如想通过3个数字表示某个试炼活动低中高三个难度的开放等级，则可定义为array[int:3]。注意array类型中的元素会按1、2、3依次作为table的key，无法像dict那样为每个元素指定key名
⑧ tableString 用于以字符串形式表达的复杂嵌套的table结构，格式为tableString[格式]，每组数据的key和value分为用k、v声明，中间用|分隔。特殊符号#seq表示自动按顺序编号，#true表示自动填写value值为true，#table表示value值是一个table，#后加数字表示用填写的该组数据中的第几个表示，自定义的变量在值后面需要在()内标明数据类型，只支持string、int、float、lang、bool这几种最基础类型。填写的具体数据中，两个数据之间用英文分号;隔开，一个数据中的不同变量用英文逗号,隔开。注意整个输入的tableString字符串中不允许出现英文引号、斜杠，string类型字符串中不允许出现英文逗号、分号，lang类型数据所填的key必须在lang文件中能找到对应的字符串值，且字符串中不含有英文引号、斜杠、逗号、分号

   示例：1)比如填写了某一场PVE战斗中的怪物组 10001;10003;10021 填写格式为 tableString[k:#1(int)|v:#true]
           这样程序会生成为：
		{
		   [10001] = true,
		   [10003] = true,
		   [10021] = true,
		}
           如果格式写为  tableString[k:#seq|v:#1(int)]，则程序会生成为:
		{
		   [1] = 10001,
		   [2] = 10003,
		   [3] = 10021,
		}
           推荐采用第1种生成方式，这样可以通过直接索引获知填写的数据中有没有指定数据，而第2种生成的结果就只能for循环遍历后才能获知

         2）比如填写某场战斗后奖励物 1,90001,500;2,90002,10 填写格式为 tableString[k:#seq|v:#table(type=#1(int),id=#2(int),count=#3(int))] 程序会生成为:
		{
		   [1] = {
			    type = 1,
			    id = 90001,
			    count = 500,
			 },
		   [2] = ……
		}
		   

注意：
① dict和array是可以互相嵌套或者自身嵌套自身使用组成更为复杂的数据类型，但均只允许嵌套1次
② dict和array的声明均占用一列，如果某行数据希望该列有效则留空，如果填-1表示该行数据不需要此字段信息。但注意array的子元素中，如果某个子元素字段用-1声明为无效，则后续的子元素也必须声明为无效的。比如配置的某一关推图的奖励列表为array[dict[3]:5]，如果配置时本关卡只奖励两种道具，则必须配置在第1、2个子元素中，后3个子元素标为无效

---------------------------------------------------------------------------------------------------------
表格检查支持的规则如下：

首先，表格中第一列为ID列，生成工具会以此列作为lua table的key，该列默认包含unique规则，禁止重复
① [1,10] 用于数字型数据【int、float】，要求取值范围必须在1到10之间，[]表示闭区间，()表示开区间，可以组合使用，比如(1,5]表示一个大于1小于或等于5的范围。如果不限制上下限范围，可以用*代替，比如(*,5]或者[*,5]表示一个小于等于5的数字，同理[5,*]或者[5,*)表示一个大于等于5的数字
② {1,5,6} 用于【int、float、string】型，来设定数据取值必须为指定合法取值中的一个，int或float型数值之间用英文逗号分隔即可，string型的需要在最后面的括号中声明分隔各个有效值的一个字符，比如{"a";"b"}(;)，如果没有声明则默认用英文逗号分隔
③ notEmpty 用于【string、lang】型，如果是string类型要求字符串不能为空但允许为连续空格字符串，如果也不允许为连续空格字符串，需要声明为notEmpty[trim]。如果是lang类型，填写notEmpty[key]只检查是否填写了key值，填写notEmpty[value]只检查填写的key在相应的lang文件中能找到对应的value，填写notEmpty[key|value]则既要求所有数据都填写lang文件中的key，也要求对应的value在lang文件中都能找到，如果填写notEmpty则与notEmpty[key|value]相同
④ unique 用于【int、float、string、lang】型，要求所有该列数据不能有重复（注意string型、lang型如果填写或者找到的value为空字符串，允许出现多次为空的情况。lang型默认只检查key不能重复，如果还想检查value需要声明为unique[value]
⑤ ref 用于【int、float、string】型，要求该列的值必须存在于另外某个表格中的一列（注意不支持引用一个array或者dict中的字段，要检查引用关系的两列必须为相同的数据类型，string型数据忽略对空字符串的检测）。比如战斗关卡表中，填写了通关后奖励道具的ID，需要检查这个ID是否存在于prop道具表中，以免人为疏忽填写成了一个不存在的ID。格式写法为：ref：表格名-列变量名，如果列为表格第一列，可以不显式声明列变量名
⑥ $后面跟自定义的字符 表示自定义的取值范围规则，其具体规则在config文件中，比如游戏中道具品质目前为1,2,3共三级但以后很可能去增加更高品质，如果凡是各种表格用到此类型的都写为{1,2,3}，那以后新增就得把所有表格中这种检查条件全部手工修改一遍，非常不方便。故此功能允许自定义一个$propQuality检查规则填写在表格中，在config中填写$propQuality:{1,2,3}
⑦ file 用于【string】型，要求输入的资源路径对应的资源必须在项目中存在，格式为file(扩展名):路径，填写的路径为相对项目Client目录的相对路径。如果file后直接写英文冒号而后加路径，单元格中必须每一个都写上扩展名（用于文件扩展名可能不同的特殊情况，不建议项目中出现此情况）。而如果file后在英文括号中声明文件的扩展名（仅允许一种），如file(png):\Assert\Resources\Texture\，单元格中则无需声明
⑧ func 用于复杂检测规则，当检查规则复杂到只能人为写函数去检查时使用，格式为func:checkReward，即func冒号后跟上自定义的函数名，函数写在MyCheckFunction.cs中。本程序会通过反射的方式调用对应函数进行检查，比如一个reward是通过dict[3] type(int)、id(int)、count(int)来定义的，通过自定义检查函数就可以检查类型是否存在，如果是英雄类型检查id在Hero表中是否存在，如果是道具类型，检查id在Prop表中是否存在。并且检查奖励的数量是否大于0等等
目前在MyCheckFunction中提供了用于检查奖励列表是否正确的CheckRewardList函数作为样例，该函数对字段进行如下检查：要求字段的数据结构必须为array[dict[3]:n]，定义一种奖励类型的三个int型字段分别叫type、id、count，每个奖励项的类型必须存在，除道具类型之外不允许奖励同一种类型，奖励数量必须大于0，如果是道具类型则道具id在道具表中要存在

如果需要多个检查规则，两个相邻规则之间用&&隔开，但需要自己注意规则是否合理不能互相冲突

---------------------------------------------------------------------------------------------------------